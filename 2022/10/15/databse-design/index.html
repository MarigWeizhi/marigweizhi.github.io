<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>数据库笔记4-数据库设计 | 未知のBlogger</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="未知のBlogger" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">未知のBlogger</a></h1></div><p class="m-desc">命里有时终须有,<br>命里无时莫强求！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">数据库笔记4-数据库设计</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2022/10/15/databse-design/">2022-10-15</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/database/">database</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h1 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h1><ul>
<li>数据库系统的三级模式结构是指数据库系统是由外模式、模式、内模式三级构成；  </li>
<li>数据与程序之间的独立性，使得数据的定义和描述可以从应用中分离出去。</li>
</ul>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><blockquote>
<p>模式也称逻辑模式，是数据库中<code>全体数据的逻辑结构</code>和特征的描述，是所有用户的公共数据视图。</p>
</blockquote>
<ul>
<li>定义模式时不仅要定义数据的<code>逻辑结构</code>，还要定义<code>数据之间的联系</code>，定义数据有关的<code>安全性、完整性要求</code>。</li>
</ul>
<h2 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h2><blockquote>
<p>也称<code>子模式</code>或<code>用户模式</code>，它是数据库用户能够看见和使用的<code>局部数据的逻辑结构</code>和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。  </p>
</blockquote>
<ul>
<li>一个数据库可以有多个外模式；  </li>
<li>同一外模式可以为某一用户的多个应用使用；  </li>
<li>一个应用程序只能使用一个外模式；</li>
</ul>
<h2 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h2><blockquote>
<p>也称<code>存储模式</code>，它是<code>数据物理结构</code>和存储方式的描述，是数据在数据库内部的表示方式。  </p>
</blockquote>
<ul>
<li>一个数据库只有一个内模式</li>
</ul>
<h2 id="外模式-模式映象"><a href="#外模式-模式映象" class="headerlink" title="外模式&#x2F;模式映象"></a>外模式&#x2F;模式映象</h2><ul>
<li>每一个外模式，都有一个外模式&#x2F;模式映像，这些映像通常包含在外模式的描述中；   </li>
<li>模式改变时，只需改变外模式&#x2F;模式映像，使得外模式保持不变，进而保证应用程序不用改变；  </li>
<li>保证了数据与程序的逻辑独立性，简称数据的逻辑独立性；</li>
</ul>
<h2 id="模式-内模式映象"><a href="#模式-内模式映象" class="headerlink" title="模式&#x2F;内模式映象"></a>模式&#x2F;内模式映象</h2><ul>
<li>内模式唯一，因此模式&#x2F;内模式映像唯一，定义了数据全局逻辑结构与存储结构的对应关系，通常包含在模式的描述中；  </li>
<li>内模式改变时，只需改变模式&#x2F;内模式映像，使得模式保持不变，进而保证应用程序不用改变；  </li>
<li>保证了数据与程序的物理独立性，简称数据的物理独立性；</li>
</ul>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p><code>主属性</code>:属于某个候选码的属性。<br><code>非主属性</code>:不属于任何候选码的属性。  </p>
<h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><blockquote>
<p>如果一个关系模式R的所有属性都是不可分的基本数据项则R属于第一范式</p>
</blockquote>
<p>第一范式是对关系模式的最起码的要求，不满足则不能成为关系数据库。</p>
<h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><blockquote>
<p>若R属于第一范式，且每个非主属性都完全函数依赖于码则R属于第二范式，即每一行被码唯一标识。</p>
</blockquote>
<h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><blockquote>
<p>若R每个非主属性都不传递依赖于R的码则属于第三范式。即第三范式要求一个数据库表中不能包含其他表中已包含的非码信息。</p>
</blockquote>
<h2 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h2><blockquote>
<p>关系模式R&lt;U,F&gt;属于第一范式，若X→Y 且Y→X时X必含有码，即每个属性都不传递依赖于R的码，则R属于BC范式。等价于每一个决定因素都包含码，即消除任何属性对码的部分和传递函数依赖。</p>
</blockquote>
<p>结论：</p>
<ol>
<li>所有非主属性对每一个码都是完全函数依赖。</li>
<li>所有主属性对每一个不包含它的码也是完全函数依赖。</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性。</li>
<li>属于BCNF一定属于3NF，反之则不一定。</li>
</ol>
<p>简单理解：若A能推出B，且B不在A的内部，则A必包含码，如能找到反例则不属于BCNF。<br>简称：每个决定因素都含有码</p>
<ul>
<li>R属于BC范式是R属于第三范式的充分不必要条件；</li>
<li>若R属于第三范式，且R只有一个候选码，则R属于BC范式是R属于第三范式的充要条件。</li>
</ul>
<h2 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h2><blockquote>
<p>R(U)是属性集U上的关系模式，XYZ是U的子集，并且Z&#x3D;U-X-Y。关心模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任意关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x的值而与z的值无关。</p>
</blockquote>
<p>若X→→Y，而Z为空，则X→→Y为平凡的多值依赖。</p>
<ul>
<li>增广律：如果X→→Y，V包含于W包含于U，则WX→→VY。</li>
<li>传递律：如果X→→Y，Y→→Z，则X→→Z-Y</li>
<li>补余律：如果X→→Y，则X→→U-X-Y</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Shishishi888/article/details/90144652">多值依赖扩展参考博客</a></p>
<h2 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h2><blockquote>
<p>4NF，关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。如果属于第四范式，则必属于BC范式。</p>
</blockquote>
<ul>
<li>任意二元关系一定是4NF</li>
</ul>
<p><em><strong>总结</strong></em></p>
<table>
<thead>
<tr>
<th>规范化</th>
<th>步骤</th>
</tr>
</thead>
<tbody><tr>
<td>1NF到2NF</td>
<td>消除非主属性对码的部分函数依赖</td>
</tr>
<tr>
<td>2NF到3NF</td>
<td>消除非主属性对码的传递函数依赖</td>
</tr>
<tr>
<td>3NF到BCNF</td>
<td>消除主属性对码的部分和传递函数依赖</td>
</tr>
<tr>
<td>BCNF到4NF</td>
<td>消除非平凡且非函数依赖的多值依赖</td>
</tr>
</tbody></table>
<h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><ul>
<li>分解具有无损连接性</li>
<li>分解要保持函数依赖</li>
<li>分解既要d保持函数依赖，又要具有无损连接性</li>
</ul>
<p>以上三个定义是实行分解的三个不同准则，不同的分解准则，模式所能达到的分离程度不同，各种范式就是对分离程度的测度。</p>
<h3 id="无损连接判断："><a href="#无损连接判断：" class="headerlink" title="无损连接判断："></a>无损连接判断：</h3><p>无损连接定理<br>关系模式R(U，F)的一个分解，ρ&#x3D;{R1&lt;U1,F1&gt;,R2&lt;U2,F2&gt;}具有无损连接的充分必要条件是：<br>U1∩U2→U1-U2 €F+ 或U1∩U2→U2 -U1€F+ </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34246965/article/details/115943652">数据库模式分解是否为无损连接和是否保持函数依赖的判断方法</a></p>
<h1 id="数据库设计步骤"><a href="#数据库设计步骤" class="headerlink" title="数据库设计步骤"></a>数据库设计步骤</h1><ol>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
<li>数据库实施</li>
<li>数据库运行维护</li>
</ol>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><blockquote>
<p>对应系统的整个应用情况作全面的详细的调查，确定用户的目标和需求，并把要求写成用户和数据库设计者都能够接受的文档。  </p>
</blockquote>
<p>输入：<code>信息需求</code>、<code>处理需求</code>、<code>安全性和完整性需求</code><br>输出：需求说明书  </p>
<ul>
<li>数据字典：是对系统中数据的详尽描述，提供对数据库数据描述的集中管理。包含数据项、数据结构、数据流、数据存储和加工过程。</li>
</ul>
<h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><blockquote>
<p>反应企业组织信息需求的数据库概念结构。独立于数据库逻辑结构，独立于DBMS，不依赖于计算机系统。</p>
</blockquote>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><blockquote>
<p>描述现实世界关系概念模型的有效方法,完成对系统中数据部分设计。  </p>
</blockquote>
<p>ER图三要素:</p>
<ul>
<li>实体：实体可以时具体的人、事、物，也可以是抽象的概念或联系。用矩形表示。</li>
<li>属性：实体所具有的某一特征，用椭圆形表示，并用无向边将其与相应的实体连接起来。<em><strong>属性不可再分，不可与其他实体有联系。</strong></em></li>
<li>联系：实体内部或实体间的关联，用菱形表示，用无向边连接相应实体，并在无向边旁边表明联系的类型(1:1,1:n,n:m)。</li>
</ul>
<h4 id="E-R图扩展"><a href="#E-R图扩展" class="headerlink" title="E-R图扩展"></a>E-R图扩展</h4><h5 id="IAS联系"><a href="#IAS联系" class="headerlink" title="IAS联系"></a>IAS联系</h5><ul>
<li>父类实体与子类实体之间的联系称为<code>ISA联系</code>，用三角形表示。例如：研究生 is a 学生。</li>
<li>分类属性：三角形旁边可以标明<code>分类属性</code>，分类属性的值表示该父实体型被分派到的子实体型中。</li>
<li>不相交约束与可重叠约束：若父类实体不能同时属于多个子类中的实体集，则称为<code>不相交约束</code>，否则称为<code>可重叠约束</code>,其中不相交约束在三角形内画一个X。</li>
<li>完备性约束：若父类实体必须为某一个子类实体则称为<code>完全特化</code>用父类子类用双线连接,否则为<code>部分特化</code>用单线连接。</li>
</ul>
<h5 id="基数约束"><a href="#基数约束" class="headerlink" title="基数约束"></a>基数约束</h5><blockquote>
<p>是1:1、1:n、n:m的细化，用<code>min..max</code>表示。  </p>
</blockquote>
<ul>
<li>0≤min≤max,例如0..1，1..3，1..* (*表示无穷大)。</li>
<li>当min&#x3D;1时，约束称为<code>强制参与约束</code>，即实体型每个实体都要参与；min&#x3D;0则为<code>非强制参与约束</code>，可以不在联系中。</li>
</ul>
<p>例1:班级与学生，一个学生必须加入一个班级且只能加入一个班级，一个班级可以容纳30到40名学生。因此在学生一端的联系上标 30..40 ，在班级的一端的联系上标 1..1。</p>
<h5 id="独占联系"><a href="#独占联系" class="headerlink" title="独占联系"></a>独占联系</h5><ul>
<li>依赖其他实体存在的实体称为<code>弱实体</code>用双矩形表示，反之则为<code>强实体</code>，强实体与弱实体之间的联系称为<code>独占联系</code>(Part-of)用双菱形表示。</li>
<li>弱实体一般没有作为码的属性。</li>
</ul>
<p>例1：一次贷款可以有多次还款，显然”还款”实体依赖于”贷款”实体存在。<br>例2：楼房包含多个房间，房间有房间号，但是房间号不能区别在哪个楼房，因此房间依赖楼房存在。</p>
<p>大型项目一般采取自底向上的方法，先设计子系统的分E-R图，然后进行合并成最终的E-R图。</p>
<h4 id="E-R图的冲突"><a href="#E-R图的冲突" class="headerlink" title="E-R图的冲突"></a>E-R图的冲突</h4><p>合并过程一般会出现三类冲突：<code>属性冲突</code>、<code>命名冲突</code>、<code>结构冲突</code>。</p>
<ul>
<li><em><strong>属性冲突</strong></em></li>
</ul>
<ol>
<li>属性域冲突：例如数据类型、取值范围</li>
<li>属性单位冲突：例如市斤、公斤</li>
</ol>
<ul>
<li><em><strong>命名冲突</strong></em></li>
</ul>
<ol>
<li>同名异义</li>
<li>异名同义</li>
</ol>
<ul>
<li><em><strong>结构冲突</strong></em></li>
</ul>
<ol>
<li>同一对象在不同应用中具有不同的抽象<br>例如：职工在局部为实体，在别处为属性。一般将统一对象变成同一抽象（都为实体或都为属性）</li>
<li>同一实体在不同子E-R图中的属性个数、排列方式不一致<br>取同一实体的不同部分属性取并集，并统一排列方式即可。</li>
<li>实体间的联系在不同的E-R图中为不同类型<br>例如：产品和零件有构成关系，产品、零件和供应商有供应关系，两个子图合并时因为”构成”和”供应”两个联系不能相包含，因此将其综合起来，两个关系同时存在。</li>
</ol>
<h4 id="消除E-R图冗余"><a href="#消除E-R图冗余" class="headerlink" title="消除E-R图冗余"></a>消除E-R图冗余</h4><p>在合并之后，消除冗余的数据和实体间冗余的联系。冗余的数据是可由基本数据导出的数据。冗余联系是指可由其他联系导出的联系。</p>
<h2 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h2><blockquote>
<p>把概念结构中的ER图转换成具体DBMS所支持的数据模式相符合的逻辑结构。（包括数据库模式、外模式）  </p>
</blockquote>
<p>步骤： </p>
<ol>
<li>E-R图向关系模式的转换</li>
<li>数据模型的优化<br>不是规范化越高的的关系越优，适当的冗余可以提高查询效率。</li>
<li>设计用户子模式<br>使用符合用户习惯的别名、针对不同级别的用户定义视图、简化用户多系统的使用。</li>
</ol>
<h2 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h2><blockquote>
<p>对给定的逻辑数据模型选取一个合适的物理结构。主要指物理设备上的存储结构和存取方法。   </p>
</blockquote>
<p><em><strong>数据库存储结构：</strong></em><br>一般基于<code>存取时间</code>、<code>存储空间利用率</code>、<code>维护代价</code>三方面权衡。<br>存放位置：</p>
<ul>
<li>稳定部分和易变部分分开存放</li>
<li>数据大表、数据和索引、日志文件和数据库对象存在多个不同的磁盘阵列，并行存取，提高效率</li>
</ul>
<p><em><strong>关系模式存取方法的选择：</strong></em><br>索引法（B+树、Hash）、聚簇(clustering)</p>
<h3 id="B-树索引法"><a href="#B-树索引法" class="headerlink" title="B+树索引法"></a>B+树索引法</h3><p>一般条件：</p>
<ol>
<li>一个(组)属性经常在查询条件中出现，考虑在该属性上建立(组合)索引</li>
<li>一个属性经常作为最大值和最小值等聚集函数的参数，考虑建立索引</li>
<li>一个(组)属性经常在连接操作的连接条件中出现，考虑建立索引</li>
</ol>
<p><em><strong>注意：</strong></em><br>若一个关系更新频率很高，则要花费大量时间更新索引，因此不适合建立太多索引</p>
<h3 id="Hash索引法"><a href="#Hash索引法" class="headerlink" title="Hash索引法"></a>Hash索引法</h3><p>一般条件:</p>
<ol>
<li>一个关系的大小可预知，且不变。</li>
<li>关系的大小动态改变，但数据库管理系统提供了动态hash存储方法。</li>
</ol>
<h3 id="聚簇"><a href="#聚簇" class="headerlink" title="聚簇"></a>聚簇</h3><blockquote>
<p>为提高某个属性(组)的查询速度，将这些属性上具有相同值的元组存在连续的物理块中称为聚簇。该属性(组)称为<code>聚簇码</code>(cluster key)  </p>
</blockquote>
<h4 id="聚簇的优点"><a href="#聚簇的优点" class="headerlink" title="聚簇的优点"></a>聚簇的优点</h4><ul>
<li>在数据库系统中，I&#x2F;O操作的时间开销很大，而聚簇大大降低了I&#x2F;O操作</li>
<li>聚簇也适用于多个常用于连接的关系，即把多个连接关系的元组按连接属性值聚簇存放，相当于<code>预连接</code>。</li>
<li>一个数据库可以有多个聚簇，一个关系只能加入一个聚簇。</li>
</ul>
<h4 id="聚簇的缺点"><a href="#聚簇的缺点" class="headerlink" title="聚簇的缺点"></a>聚簇的缺点</h4><ul>
<li>聚簇建立维护开销很大，需要与优点权衡</li>
<li>对已有关系建立聚簇，会移动数据的物理地址，即原索引全部失效，需要重新建立索引</li>
<li>聚簇码值修改会导致数据物理地址移动</li>
</ul>
<h4 id="聚簇的选择要求"><a href="#聚簇的选择要求" class="headerlink" title="聚簇的选择要求"></a>聚簇的选择要求</h4><ul>
<li>经常进行连接操作的关系</li>
<li>关系中的一组属性经常出现在相等比较中</li>
<li>关系的个或一组属性上的值重复率很高。即聚簇码值平均元组数不能太少。</li>
<li>SQL语句经常出现<code>ORDER BY</code>、<code>GROUP BY</code>、<code>UNION</code>、<code>DISTINCT</code>等子句。</li>
<li>不经常进行全表扫描</li>
<li>连接操作多于更新操作</li>
<li>一个表只能加入一个聚簇，如果有一个表符合多个，则选择最优的</li>
</ul>
<h1 id="约束的使用"><a href="#约束的使用" class="headerlink" title="约束的使用"></a>约束的使用</h1><h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><blockquote>
<p>关系模型中的实体完整性在create table 中用<code>primary key</code>定义（对单属性构成的码可以定义为列级约束条件，也可以定义为表级约束条件，而对于多个属性构成的码只有一种说明方法，即定义为表级约束条件）。</p>
</blockquote>
<p>检查与违约处理：</p>
<ul>
<li>检查主码是否唯一，如果不唯一则拒绝插入或修改。</li>
<li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</li>
</ul>
<h2 id="参照整性"><a href="#参照整性" class="headerlink" title="参照整性"></a>参照整性</h2><blockquote>
<p>关系模型的参照完整性在create table中使用foreign key短语定义哪些列为外码，用reference短语指明这些外码参照哪些表的主码。</p>
</blockquote>
<p>参照表与参照表的违约处理：</p>
<table>
<thead>
<tr>
<th>被参照表</th>
<th>参照表</th>
<th>违约处理</th>
</tr>
</thead>
<tbody><tr>
<td>可能破坏参照完整性</td>
<td>插入元组</td>
<td>拒绝</td>
</tr>
<tr>
<td>可能破坏参照完整性</td>
<td>修改外码值</td>
<td>拒绝</td>
</tr>
<tr>
<td>删除元组</td>
<td>可能破坏参照完整性</td>
<td>拒绝&#x2F;级联删除&#x2F;设置为空</td>
</tr>
<tr>
<td>修改主码</td>
<td>可能破坏参照完整性</td>
<td>拒绝&#x2F;级联删除&#x2F;设置为空</td>
</tr>
</tbody></table>
<h2 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h2><blockquote>
<p>用户定义完整性就是针对某一具体应用的数据必须满足的语义要求。  </p>
</blockquote>
<ol>
<li>属性上的约束条件  <ol>
<li>列值非空（<code>NOT NULL</code>）</li>
<li>列值唯一（<code>UNIQUE</code>）</li>
<li>列值是否满足条件表达式（<code>CHECK</code>）</li>
</ol>
</li>
<li>元组上的约束条件<br>在create table语句中可以使用check定义元组上的约束条件。例如<code>check (sex = &#39;女&#39; or name not like &#39;Ms.%&#39;)</code>，即男性姓名不以Ms.开头</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>完整性类型</th>
<th>约束类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>实体完整性</td>
<td>PRIMARY KEY</td>
<td>唯一标识每一行，保证用户不输入重复的数据，且创建一个索引来提高性能，不允许空值</td>
</tr>
<tr>
<td>实体完整性</td>
<td>UNIQUE</td>
<td>防止非主键关键字的重复，并保证创建一个索引来提高性能，允许空值（最多一个）</td>
</tr>
<tr>
<td>用户定义完整性</td>
<td>DEFAULT</td>
<td>指定在INSERT语句中没有明确提供一个值时，为该列提供的值</td>
</tr>
<tr>
<td>用户定义完整性</td>
<td>CHECK</td>
<td>指定在一个列中可接受的数据值</td>
</tr>
<tr>
<td>参照完整性</td>
<td>FOREIGN KEY</td>
<td>定义一个列或几个列的组合，他们的值匹配同一个表或另一个表中的关键字</td>
</tr>
</tbody></table>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h3 id="1-关系模式R-商店编号、商品编号、数量、部门编号、负责人-，规定，每个商店的每种商品只在一个部门销售；每个商店的每个部门只有一个负责人；每个商店的每个商品只有一个数量；求函数依赖关系和分解成3NF模式集；"><a href="#1-关系模式R-商店编号、商品编号、数量、部门编号、负责人-，规定，每个商店的每种商品只在一个部门销售；每个商店的每个部门只有一个负责人；每个商店的每个商品只有一个数量；求函数依赖关系和分解成3NF模式集；" class="headerlink" title="1. 关系模式R(商店编号、商品编号、数量、部门编号、负责人)，规定，每个商店的每种商品只在一个部门销售；每个商店的每个部门只有一个负责人；每个商店的每个商品只有一个数量；求函数依赖关系和分解成3NF模式集；"></a>1. 关系模式R(商店编号、商品编号、数量、部门编号、负责人)，规定，每个商店的每种商品只在一个部门销售；每个商店的每个部门只有一个负责人；每个商店的每个商品只有一个数量；求函数依赖关系和分解成3NF模式集；</h3><blockquote>
<p>依赖关系：<br>(商店编号,商品编号) -&gt; 数量；<br>(商店编号,商品编号) -&gt; 部门编号；<br>(商店编号,部门编号) -&gt; 负责人；<br>分解：<br>R1(商店编号,商品编号,部门编号,数量)<br>R2(商店编号,部门编号,负责人)   </p>
</blockquote>
<h3 id="2-试述数据库设计过程中形成的数据库模式"><a href="#2-试述数据库设计过程中形成的数据库模式" class="headerlink" title="2. 试述数据库设计过程中形成的数据库模式"></a>2. 试述数据库设计过程中形成的数据库模式</h3><blockquote>
<ul>
<li>在概念结构设计阶段，独立于DBMS绘制E-R图，形成概念模式</li>
<li>在逻辑结构设计阶段，E-R图转成数据库支持的数据模型、创建视图，形成外模式</li>
<li>是物理结构设计阶段，规划存取策略、建立索引，形成内模式</li>
</ul>
</blockquote>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">Marig_Weizhi</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2022/10/15/databse-design/">http://marigweizhi.github.io/2022/10/15/databse-design/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="http://marigweizhi.github.io">Marig_Weizhi的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tag"></i><a href="/tags/database/">database</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">数据库模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">外模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">内模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E5%BC%8F%E6%98%A0%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">外模式&#x2F;模式映象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-%E5%86%85%E6%A8%A1%E5%BC%8F%E6%98%A0%E8%B1%A1"><span class="toc-number">1.5.</span> <span class="toc-text">模式&#x2F;内模式映象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">范式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1NF"><span class="toc-number">2.1.</span> <span class="toc-text">1NF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2NF"><span class="toc-number">2.2.</span> <span class="toc-text">2NF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3NF"><span class="toc-number">2.3.</span> <span class="toc-text">3NF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BCNF"><span class="toc-number">2.4.</span> <span class="toc-text">BCNF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"><span class="toc-number">2.5.</span> <span class="toc-text">多值依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4NF"><span class="toc-number">2.6.</span> <span class="toc-text">4NF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3"><span class="toc-number">2.7.</span> <span class="toc-text">模式分解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%88%A4%E6%96%AD%EF%BC%9A"><span class="toc-number">2.7.1.</span> <span class="toc-text">无损连接判断：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.</span> <span class="toc-text">数据库设计步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">3.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.2.</span> <span class="toc-text">概念结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ER%E5%9B%BE"><span class="toc-number">3.2.1.</span> <span class="toc-text">ER图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#E-R%E5%9B%BE%E6%89%A9%E5%B1%95"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">E-R图扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IAS%E8%81%94%E7%B3%BB"><span class="toc-number">3.2.1.1.1.</span> <span class="toc-text">IAS联系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.2.1.1.2.</span> <span class="toc-text">基数约束</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E8%81%94%E7%B3%BB"><span class="toc-number">3.2.1.1.3.</span> <span class="toc-text">独占联系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-R%E5%9B%BE%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">E-R图的冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4E-R%E5%9B%BE%E5%86%97%E4%BD%99"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">消除E-R图冗余</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.</span> <span class="toc-text">逻辑结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.4.</span> <span class="toc-text">物理结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E6%B3%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">B+树索引法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">Hash索引法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87"><span class="toc-number">3.4.3.</span> <span class="toc-text">聚簇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">聚簇的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">聚簇的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%9A%84%E9%80%89%E6%8B%A9%E8%A6%81%E6%B1%82"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">聚簇的选择要求</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">约束的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">实体完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E7%85%A7%E6%95%B4%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">参照整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">用户定义完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8FR-%E5%95%86%E5%BA%97%E7%BC%96%E5%8F%B7%E3%80%81%E5%95%86%E5%93%81%E7%BC%96%E5%8F%B7%E3%80%81%E6%95%B0%E9%87%8F%E3%80%81%E9%83%A8%E9%97%A8%E7%BC%96%E5%8F%B7%E3%80%81%E8%B4%9F%E8%B4%A3%E4%BA%BA-%EF%BC%8C%E8%A7%84%E5%AE%9A%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%95%86%E5%BA%97%E7%9A%84%E6%AF%8F%E7%A7%8D%E5%95%86%E5%93%81%E5%8F%AA%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%83%A8%E9%97%A8%E9%94%80%E5%94%AE%EF%BC%9B%E6%AF%8F%E4%B8%AA%E5%95%86%E5%BA%97%E7%9A%84%E6%AF%8F%E4%B8%AA%E9%83%A8%E9%97%A8%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E8%B4%9F%E8%B4%A3%E4%BA%BA%EF%BC%9B%E6%AF%8F%E4%B8%AA%E5%95%86%E5%BA%97%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%95%86%E5%93%81%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E9%87%8F%EF%BC%9B%E6%B1%82%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%92%8C%E5%88%86%E8%A7%A3%E6%88%903NF%E6%A8%A1%E5%BC%8F%E9%9B%86%EF%BC%9B"><span class="toc-number">5.0.1.</span> <span class="toc-text">1. 关系模式R(商店编号、商品编号、数量、部门编号、负责人)，规定，每个商店的每种商品只在一个部门销售；每个商店的每个部门只有一个负责人；每个商店的每个商品只有一个数量；求函数依赖关系和分解成3NF模式集；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%95%E8%BF%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BD%A2%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. 试述数据库设计过程中形成的数据库模式</span></a></li></ol></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2022/10/16/database-principles/">&lt; 数据库笔记5-数据库基本原理</a><a class="next" href="/2022/10/15/relationship-model/">数据库笔记3-关系模型 &gt;</a></div></section><footer><p>Copyright © 2016 - 2024 <a href="/." rel="nofollow">未知のBlogger</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>